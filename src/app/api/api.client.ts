//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginModel | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/Authentication/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getUserInfo(): Observable<SwaggerResponse<UserInfoDto>> {
        let url_ = this.baseUrl + "/api/Authentication/get-user-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UserInfoDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UserInfoDto>>;
        }));
    }

    protected processGetUserInfo(response: HttpResponseBase): Observable<SwaggerResponse<UserInfoDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserInfoDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UserInfoDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterModel | undefined): Observable<SwaggerResponse<RegisterModelCommonResultDto>> {
        let url_ = this.baseUrl + "/api/Authentication/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<RegisterModelCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<RegisterModelCommonResultDto>>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<SwaggerResponse<RegisterModelCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterModelCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<RegisterModelCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerAdmin(body: RegisterModel | undefined): Observable<SwaggerResponse<RegisterModelCommonResultDto>> {
        let url_ = this.baseUrl + "/api/Authentication/register-admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<RegisterModelCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<RegisterModelCommonResultDto>>;
        }));
    }

    protected processRegisterAdmin(response: HttpResponseBase): Observable<SwaggerResponse<RegisterModelCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterModelCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<RegisterModelCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    baoCaoNhap(body: SearchListDto | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/BaoCao/bao-cao-nhap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaoCaoNhap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaoCaoNhap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processBaoCaoNhap(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    exportPdfPhieuNhapXuat(id: number | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/BaoCao/export-pdf-phieu-nhap-xuat?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportPdfPhieuNhapXuat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportPdfPhieuNhapXuat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processExportPdfPhieuNhapXuat(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    baoCaoXuat(body: SearchListDto | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/BaoCao/bao-cao-xuat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaoCaoXuat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaoCaoXuat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processBaoCaoXuat(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    baoCaoBaoDuong(body: PhieuBaoDuongInputDto | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/BaoCao/bao-cao-bao-duong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaoCaoBaoDuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaoCaoBaoDuong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processBaoCaoBaoDuong(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    baoCaoSuaChua(body: PhieuSuaChuaInputDto | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/BaoCao/bao-cao-sua-chua";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaoCaoSuaChua(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaoCaoSuaChua(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processBaoCaoSuaChua(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SearchListDto | undefined): Observable<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/DanhSachThietBi/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListByUser(body: SearchListDto | undefined): Observable<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/DanhSachThietBi/get-list-by-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>>;
        }));
    }

    protected processGetListByUser(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getAllMa(): Observable<SwaggerResponse<string[]>> {
        let url_ = this.baseUrl + "/api/DanhSachThietBi/get-all-ma";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<string[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<string[]>>;
        }));
    }

    protected processGetAllMa(response: HttpResponseBase): Observable<SwaggerResponse<string[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<string[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<SwaggerResponse<ThongTinChiTietThietBiDto>> {
        let url_ = this.baseUrl + "/api/DanhSachThietBi/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiDto>>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/DanhSachThietBi/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(id: number | undefined, body: ThongTinChiTietThietBiDto | undefined): Observable<SwaggerResponse<ThongTinChiTietThietBiDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/DanhSachThietBi/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiDtoCommonResultDto>>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: ThongTinThietBiReaderDto[] | undefined): Observable<SwaggerResponse<BooleanCommonResultDto>> {
        let url_ = this.baseUrl + "/api/DanhSachThietBi/create-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<BooleanCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<BooleanCommonResultDto>>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<SwaggerResponse<BooleanCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<BooleanCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    uploadExcel(files: FileParameter | undefined): Observable<SwaggerResponse<ThongTinThietBiReaderDtoReadFileExcelDto>> {
        let url_ = this.baseUrl + "/api/DanhSachThietBi/UploadExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            content_.append("files", files.data, files.fileName ? files.fileName : "files");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinThietBiReaderDtoReadFileExcelDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinThietBiReaderDtoReadFileExcelDto>>;
        }));
    }

    protected processUploadExcel(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinThietBiReaderDtoReadFileExcelDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinThietBiReaderDtoReadFileExcelDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinThietBiReaderDtoReadFileExcelDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDashBoard(): Observable<SwaggerResponse<DashBoardTotalDto>> {
        let url_ = this.baseUrl + "/api/DashBoard/get-dash-board";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashBoard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<DashBoardTotalDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<DashBoardTotalDto>>;
        }));
    }

    protected processGetDashBoard(response: HttpResponseBase): Observable<SwaggerResponse<DashBoardTotalDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DashBoardTotalDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DashBoardTotalDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDashbaordChart(): Observable<SwaggerResponse<DashBoardChartDto[]>> {
        let url_ = this.baseUrl + "/api/DashBoard/get-dashbaord-chart";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashbaordChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashbaordChart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<DashBoardChartDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<DashBoardChartDto[]>>;
        }));
    }

    protected processGetDashbaordChart(response: HttpResponseBase): Observable<SwaggerResponse<DashBoardChartDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DashBoardChartDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DashBoardChartDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList2(body: SearchListDto | undefined): Observable<SwaggerResponse<LichSuBanGiaoDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/LichSuBanGiao/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<LichSuBanGiaoDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<LichSuBanGiaoDtoPagedResultDto>>;
        }));
    }

    protected processGetList2(response: HttpResponseBase): Observable<SwaggerResponse<LichSuBanGiaoDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LichSuBanGiaoDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<LichSuBanGiaoDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLichSuByThietBi(id: number | undefined): Observable<SwaggerResponse<LichSuBanGiaoDto[]>> {
        let url_ = this.baseUrl + "/api/LichSuBanGiao/get-lich-su-by-thiet-bi?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichSuByThietBi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichSuByThietBi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<LichSuBanGiaoDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<LichSuBanGiaoDto[]>>;
        }));
    }

    protected processGetLichSuByThietBi(response: HttpResponseBase): Observable<SwaggerResponse<LichSuBanGiaoDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LichSuBanGiaoDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<LichSuBanGiaoDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList3(body: SearchListDto | undefined): Observable<SwaggerResponse<LoaiThietBiDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/LoaiThietBi/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<LoaiThietBiDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<LoaiThietBiDtoPagedResultDto>>;
        }));
    }

    protected processGetList3(response: HttpResponseBase): Observable<SwaggerResponse<LoaiThietBiDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoaiThietBiDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<LoaiThietBiDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: LoaiThietBiDto | undefined): Observable<SwaggerResponse<LoaiThietBiDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/LoaiThietBi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<LoaiThietBiDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<LoaiThietBiDtoCommonResultDto>>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SwaggerResponse<LoaiThietBiDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoaiThietBiDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<LoaiThietBiDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById2(id: number | undefined): Observable<SwaggerResponse<LoaiThietBiDto>> {
        let url_ = this.baseUrl + "/api/LoaiThietBi/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<LoaiThietBiDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<LoaiThietBiDto>>;
        }));
    }

    protected processGetById2(response: HttpResponseBase): Observable<SwaggerResponse<LoaiThietBiDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoaiThietBiDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<LoaiThietBiDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete2(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/LoaiThietBi/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDelete2(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    update2(id: number | undefined, body: LoaiThietBiDto | undefined): Observable<SwaggerResponse<LoaiThietBiDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/LoaiThietBi/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<LoaiThietBiDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<LoaiThietBiDtoCommonResultDto>>;
        }));
    }

    protected processUpdate2(response: HttpResponseBase): Observable<SwaggerResponse<LoaiThietBiDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoaiThietBiDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<LoaiThietBiDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList4(body: SearchListDto | undefined): Observable<SwaggerResponse<NhanSuDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/NhanVien/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NhanSuDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NhanSuDtoPagedResultDto>>;
        }));
    }

    protected processGetList4(response: HttpResponseBase): Observable<SwaggerResponse<NhanSuDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NhanSuDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NhanSuDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create2(body: NhanSuDto | undefined): Observable<SwaggerResponse<NhanSuDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/NhanVien/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NhanSuDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NhanSuDtoCommonResultDto>>;
        }));
    }

    protected processCreate2(response: HttpResponseBase): Observable<SwaggerResponse<NhanSuDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NhanSuDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NhanSuDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById3(id: number | undefined): Observable<SwaggerResponse<NhanSuDto>> {
        let url_ = this.baseUrl + "/api/NhanVien/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NhanSuDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NhanSuDto>>;
        }));
    }

    protected processGetById3(response: HttpResponseBase): Observable<SwaggerResponse<NhanSuDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NhanSuDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NhanSuDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete3(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/NhanVien/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDelete3(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    update3(id: number | undefined, body: NhanSuDto | undefined): Observable<SwaggerResponse<NhanSuDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/NhanVien/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NhanSuDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NhanSuDtoCommonResultDto>>;
        }));
    }

    protected processUpdate3(response: HttpResponseBase): Observable<SwaggerResponse<NhanSuDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NhanSuDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NhanSuDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getAllKhoa(): Observable<SwaggerResponse<KhoaDto[]>> {
        let url_ = this.baseUrl + "/api/NhanVien/Get-all-khoa";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKhoa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKhoa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<KhoaDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<KhoaDto[]>>;
        }));
    }

    protected processGetAllKhoa(response: HttpResponseBase): Observable<SwaggerResponse<KhoaDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as KhoaDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<KhoaDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getCount(): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/Notification/get-count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processGetCount(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList5(body: SearchListDto | undefined): Observable<SwaggerResponse<NotificationDtoPagedResultDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/Notification/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NotificationDtoPagedResultDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NotificationDtoPagedResultDtoCommonResultDto>>;
        }));
    }

    protected processGetList5(response: HttpResponseBase): Observable<SwaggerResponse<NotificationDtoPagedResultDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationDtoPagedResultDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NotificationDtoPagedResultDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    readAll(): Observable<SwaggerResponse<BooleanCommonResultDto>> {
        let url_ = this.baseUrl + "/api/Notification/read-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<BooleanCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<BooleanCommonResultDto>>;
        }));
    }

    protected processReadAll(response: HttpResponseBase): Observable<SwaggerResponse<BooleanCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<BooleanCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList6(body: SearchListDto | undefined): Observable<SwaggerResponse<PhieuBanGiaoDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuBanGiao/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuBanGiaoDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuBanGiaoDtoPagedResultDto>>;
        }));
    }

    protected processGetList6(response: HttpResponseBase): Observable<SwaggerResponse<PhieuBanGiaoDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuBanGiaoDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuBanGiaoDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create3(body: PhieuBanGiaoDto | undefined): Observable<SwaggerResponse<PhieuBanGiaoDto>> {
        let url_ = this.baseUrl + "/api/PhieuBanGiao/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuBanGiaoDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuBanGiaoDto>>;
        }));
    }

    protected processCreate3(response: HttpResponseBase): Observable<SwaggerResponse<PhieuBanGiaoDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuBanGiaoDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuBanGiaoDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById4(id: number | undefined): Observable<SwaggerResponse<PhieuBanGiaoDto>> {
        let url_ = this.baseUrl + "/api/PhieuBanGiao/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuBanGiaoDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuBanGiaoDto>>;
        }));
    }

    protected processGetById4(response: HttpResponseBase): Observable<SwaggerResponse<PhieuBanGiaoDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuBanGiaoDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuBanGiaoDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDanhSachThietBi(): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        let url_ = this.baseUrl + "/api/PhieuBanGiao/get-danh-sach-thiet-bi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachThietBi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachThietBi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
        }));
    }

    protected processGetDanhSachThietBi(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiSelectDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList7(body: PhieuBaoDuongInputDto | undefined): Observable<SwaggerResponse<PhieuBaoDuongDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuBaoDuongDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuBaoDuongDtoPagedResultDto>>;
        }));
    }

    protected processGetList7(response: HttpResponseBase): Observable<SwaggerResponse<PhieuBaoDuongDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuBaoDuongDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuBaoDuongDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create4(body: PhieuBaoDuongDto | undefined): Observable<SwaggerResponse<PhieuBaoDuongDto>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuBaoDuongDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuBaoDuongDto>>;
        }));
    }

    protected processCreate4(response: HttpResponseBase): Observable<SwaggerResponse<PhieuBaoDuongDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuBaoDuongDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuBaoDuongDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    update4(id: number | undefined, body: PhieuBaoDuongDto | undefined): Observable<SwaggerResponse<PhieuBaoDuongDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuBaoDuongDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuBaoDuongDtoCommonResultDto>>;
        }));
    }

    protected processUpdate4(response: HttpResponseBase): Observable<SwaggerResponse<PhieuBaoDuongDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuBaoDuongDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuBaoDuongDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById5(id: number | undefined): Observable<SwaggerResponse<PhieuBaoDuongDto>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuBaoDuongDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuBaoDuongDto>>;
        }));
    }

    protected processGetById5(response: HttpResponseBase): Observable<SwaggerResponse<PhieuBaoDuongDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuBaoDuongDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuBaoDuongDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete4(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDelete4(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    approve(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/approve?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    completed(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/completed?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processCompleted(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDanhSachThietBi2(): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/get-danh-sach-thiet-bi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachThietBi2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachThietBi2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
        }));
    }

    protected processGetDanhSachThietBi2(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiSelectDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getTotalPhieuBaoDuong(): Observable<SwaggerResponse<ThongKeDto>> {
        let url_ = this.baseUrl + "/api/PhieuBaoDuong/get-total-phieu-bao-duong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalPhieuBaoDuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalPhieuBaoDuong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongKeDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongKeDto>>;
        }));
    }

    protected processGetTotalPhieuBaoDuong(response: HttpResponseBase): Observable<SwaggerResponse<ThongKeDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongKeDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongKeDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList8(body: SearchListDto | undefined): Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>;
        }));
    }

    protected processGetList8(response: HttpResponseBase): Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuNhapXuatDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListPhieuNhap(body: SearchListDto | undefined): Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-list-phieu-nhap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPhieuNhap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPhieuNhap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>;
        }));
    }

    protected processGetListPhieuNhap(response: HttpResponseBase): Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuNhapXuatDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListPhieuXuat(body: SearchListDto | undefined): Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-list-phieu-xuat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPhieuXuat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPhieuXuat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>;
        }));
    }

    protected processGetListPhieuXuat(response: HttpResponseBase): Observable<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuNhapXuatDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuNhapXuatDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create5(body: PhieuNhapXuatDto | undefined): Observable<SwaggerResponse<PhieuNhapXuatDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuNhapXuatDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuNhapXuatDtoCommonResultDto>>;
        }));
    }

    protected processCreate5(response: HttpResponseBase): Observable<SwaggerResponse<PhieuNhapXuatDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuNhapXuatDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuNhapXuatDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete5(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDelete5(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById6(id: number | undefined): Observable<SwaggerResponse<PhieuNhapXuatDto>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuNhapXuatDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuNhapXuatDto>>;
        }));
    }

    protected processGetById6(response: HttpResponseBase): Observable<SwaggerResponse<PhieuNhapXuatDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuNhapXuatDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuNhapXuatDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDanhSachThietBi3(): Observable<SwaggerResponse<ThietBiYTeDto[]>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-danh-sach-thiet-bi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachThietBi3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachThietBi3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThietBiYTeDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThietBiYTeDto[]>>;
        }));
    }

    protected processGetDanhSachThietBi3(response: HttpResponseBase): Observable<SwaggerResponse<ThietBiYTeDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThietBiYTeDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThietBiYTeDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDanhSachNhanVien(): Observable<SwaggerResponse<NhanSuDto[]>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-danh-sach-nhan-vien";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachNhanVien(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NhanSuDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NhanSuDto[]>>;
        }));
    }

    protected processGetDanhSachNhanVien(response: HttpResponseBase): Observable<SwaggerResponse<NhanSuDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NhanSuDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NhanSuDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getTotalPhieuNhap(): Observable<SwaggerResponse<ThongKeDto>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-total-phieu-nhap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalPhieuNhap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalPhieuNhap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongKeDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongKeDto>>;
        }));
    }

    protected processGetTotalPhieuNhap(response: HttpResponseBase): Observable<SwaggerResponse<ThongKeDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongKeDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongKeDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getTotalPhieuXuat(): Observable<SwaggerResponse<ThongKeDto>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-total-phieu-xuat";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalPhieuXuat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalPhieuXuat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongKeDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongKeDto>>;
        }));
    }

    protected processGetTotalPhieuXuat(response: HttpResponseBase): Observable<SwaggerResponse<ThongKeDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongKeDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongKeDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDanhSachChiTietThietBi(): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        let url_ = this.baseUrl + "/api/PhieuNhapXuat/get-danh-sach-chi-tiet-thiet-bi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachChiTietThietBi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachChiTietThietBi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
        }));
    }

    protected processGetDanhSachChiTietThietBi(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiSelectDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList9(body: PhieuSuaChuaInputDto | undefined): Observable<SwaggerResponse<PhieuSuaChuaDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuSuaChua/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuSuaChuaDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuSuaChuaDtoPagedResultDto>>;
        }));
    }

    protected processGetList9(response: HttpResponseBase): Observable<SwaggerResponse<PhieuSuaChuaDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuSuaChuaDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuSuaChuaDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create6(body: PhieuSuaChuaDto | undefined): Observable<SwaggerResponse<PhieuSuaChuaDto>> {
        let url_ = this.baseUrl + "/api/PhieuSuaChua/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuSuaChuaDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuSuaChuaDto>>;
        }));
    }

    protected processCreate6(response: HttpResponseBase): Observable<SwaggerResponse<PhieuSuaChuaDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuSuaChuaDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuSuaChuaDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById7(id: number | undefined): Observable<SwaggerResponse<PhieuSuaChuaDto>> {
        let url_ = this.baseUrl + "/api/PhieuSuaChua/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuSuaChuaDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuSuaChuaDto>>;
        }));
    }

    protected processGetById7(response: HttpResponseBase): Observable<SwaggerResponse<PhieuSuaChuaDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuSuaChuaDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuSuaChuaDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete6(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuSuaChua/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDelete6(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    approve2(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuSuaChua/approve?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processApprove2(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    completed2(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuSuaChua/completed?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleted2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleted2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processCompleted2(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deny(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuSuaChua/deny?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeny(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeny(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDeny(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDanhSachThietBi4(): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        let url_ = this.baseUrl + "/api/PhieuSuaChua/get-danh-sach-thiet-bi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachThietBi4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachThietBi4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
        }));
    }

    protected processGetDanhSachThietBi4(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiSelectDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList10(body: SearchListDto | undefined): Observable<SwaggerResponse<PhieuThuHoiDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/PhieuThuHoi/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList10(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuThuHoiDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuThuHoiDtoPagedResultDto>>;
        }));
    }

    protected processGetList10(response: HttpResponseBase): Observable<SwaggerResponse<PhieuThuHoiDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuThuHoiDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuThuHoiDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create7(body: PhieuThuHoiDto | undefined): Observable<SwaggerResponse<PhieuThuHoiDto>> {
        let url_ = this.baseUrl + "/api/PhieuThuHoi/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuThuHoiDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuThuHoiDto>>;
        }));
    }

    protected processCreate7(response: HttpResponseBase): Observable<SwaggerResponse<PhieuThuHoiDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuThuHoiDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuThuHoiDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById8(id: number | undefined): Observable<SwaggerResponse<PhieuThuHoiDto>> {
        let url_ = this.baseUrl + "/api/PhieuThuHoi/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PhieuThuHoiDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PhieuThuHoiDto>>;
        }));
    }

    protected processGetById8(response: HttpResponseBase): Observable<SwaggerResponse<PhieuThuHoiDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhieuThuHoiDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PhieuThuHoiDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    getDanhSachThietBi5(): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        let url_ = this.baseUrl + "/api/PhieuThuHoi/get-danh-sach-thiet-bi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachThietBi5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachThietBi5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>;
        }));
    }

    protected processGetDanhSachThietBi5(response: HttpResponseBase): Observable<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThongTinChiTietThietBiSelectDto[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThongTinChiTietThietBiSelectDto[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList11(body: SearchListDto | undefined): Observable<SwaggerResponse<KhoaDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/PhongBan/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList11(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<KhoaDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<KhoaDtoPagedResultDto>>;
        }));
    }

    protected processGetList11(response: HttpResponseBase): Observable<SwaggerResponse<KhoaDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as KhoaDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<KhoaDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create8(body: KhoaDto | undefined): Observable<SwaggerResponse<KhoaDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhongBan/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<KhoaDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<KhoaDtoCommonResultDto>>;
        }));
    }

    protected processCreate8(response: HttpResponseBase): Observable<SwaggerResponse<KhoaDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as KhoaDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<KhoaDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById9(id: number | undefined): Observable<SwaggerResponse<KhoaDto>> {
        let url_ = this.baseUrl + "/api/PhongBan/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<KhoaDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<KhoaDto>>;
        }));
    }

    protected processGetById9(response: HttpResponseBase): Observable<SwaggerResponse<KhoaDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as KhoaDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<KhoaDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete7(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhongBan/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDelete7(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    update5(id: number | undefined, body: KhoaDto | undefined): Observable<SwaggerResponse<KhoaDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/PhongBan/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<KhoaDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<KhoaDtoCommonResultDto>>;
        }));
    }

    protected processUpdate5(response: HttpResponseBase): Observable<SwaggerResponse<KhoaDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as KhoaDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<KhoaDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList12(body: SearchListDto | undefined): Observable<SwaggerResponse<ThietBiYTeDtoPagedResultDto>> {
        let url_ = this.baseUrl + "/api/ThietBiYTe/get-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList12(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThietBiYTeDtoPagedResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThietBiYTeDtoPagedResultDto>>;
        }));
    }

    protected processGetList12(response: HttpResponseBase): Observable<SwaggerResponse<ThietBiYTeDtoPagedResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThietBiYTeDtoPagedResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThietBiYTeDtoPagedResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create9(body: ThietBiYTeDto | undefined): Observable<SwaggerResponse<ThietBiYTeDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/ThietBiYTe/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThietBiYTeDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThietBiYTeDtoCommonResultDto>>;
        }));
    }

    protected processCreate9(response: HttpResponseBase): Observable<SwaggerResponse<ThietBiYTeDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThietBiYTeDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThietBiYTeDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById10(id: number | undefined): Observable<SwaggerResponse<ThietBiYTeDto>> {
        let url_ = this.baseUrl + "/api/ThietBiYTe/get-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById10(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThietBiYTeDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThietBiYTeDto>>;
        }));
    }

    protected processGetById10(response: HttpResponseBase): Observable<SwaggerResponse<ThietBiYTeDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThietBiYTeDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThietBiYTeDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete8(id: number | undefined): Observable<SwaggerResponse<Int32CommonResultDto>> {
        let url_ = this.baseUrl + "/api/ThietBiYTe/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<Int32CommonResultDto>>;
        }));
    }

    protected processDelete8(response: HttpResponseBase): Observable<SwaggerResponse<Int32CommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Int32CommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<Int32CommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    update6(id: number | undefined, body: ThietBiYTeDto | undefined): Observable<SwaggerResponse<ThietBiYTeDtoCommonResultDto>> {
        let url_ = this.baseUrl + "/api/ThietBiYTe/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ThietBiYTeDtoCommonResultDto>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ThietBiYTeDtoCommonResultDto>>;
        }));
    }

    protected processUpdate6(response: HttpResponseBase): Observable<SwaggerResponse<ThietBiYTeDtoCommonResultDto>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ThietBiYTeDtoCommonResultDto;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ThietBiYTeDtoCommonResultDto>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    upload(): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/UploadDanhSachThietBiControoller/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }
}

export interface BooleanCommonResultDto {
    isSuccessful?: boolean;
    result?: boolean;
    errorMessage?: string | undefined;
}

export interface DashBoardChartDto {
    category?: string | undefined;
    value?: number;
}

export interface DashBoardTotalDto {
    tongPhieuNhap?: number | undefined;
    tongPhieuXuat?: number | undefined;
    tongPhieuSuaChua?: number | undefined;
    tongPhieuBaoDuong?: number | undefined;
    tongPhieuThuHoi?: number | undefined;
    tongPhieuBanGiao?: number | undefined;
    tongTienNhap?: number | undefined;
    tongTienXuat?: number | undefined;
}

export interface Int32CommonResultDto {
    isSuccessful?: boolean;
    result?: number;
    errorMessage?: string | undefined;
}

export interface KhoaDto {
    id?: number;
    ma: string;
    ten: string;
    email?: string | undefined;
    sdt?: string | undefined;
}

export interface KhoaDtoCommonResultDto {
    isSuccessful?: boolean;
    result?: KhoaDto;
    errorMessage?: string | undefined;
}

export interface KhoaDtoPagedResultDto {
    items?: KhoaDto[] | undefined;
    totalCount?: number;
}

export interface LichSuBanGiaoDto {
    id?: number;
    ngayThucHien?: Date;
    nhanVienId?: number;
    chiTietThietBiId?: number;
}

export interface LichSuBanGiaoDtoPagedResultDto {
    items?: LichSuBanGiaoDto[] | undefined;
    totalCount?: number;
}

export interface LoaiThietBiDto {
    id?: number;
    ma?: string | undefined;
    ten?: string | undefined;
}

export interface LoaiThietBiDtoCommonResultDto {
    isSuccessful?: boolean;
    result?: LoaiThietBiDto;
    errorMessage?: string | undefined;
}

export interface LoaiThietBiDtoPagedResultDto {
    items?: LoaiThietBiDto[] | undefined;
    totalCount?: number;
}

export interface LoginModel {
    email?: string | undefined;
    password?: string | undefined;
}

export interface NhanSuDto {
    id?: number;
    ma: string;
    ten: string;
    khoaId?: number;
    email?: string | undefined;
    sdt?: string | undefined;
    diaChi?: string | undefined;
    accountId?: string | undefined;
    laQuanLyThietBi?: boolean | undefined;
}

export interface NhanSuDtoCommonResultDto {
    isSuccessful?: boolean;
    result?: NhanSuDto;
    errorMessage?: string | undefined;
}

export interface NhanSuDtoPagedResultDto {
    items?: NhanSuDto[] | undefined;
    totalCount?: number;
}

export interface NotificationDto {
    subject?: string | undefined;
    message?: string | undefined;
    sendTime?: Date;
    isRead?: boolean;
}

export interface NotificationDtoPagedResultDto {
    items?: NotificationDto[] | undefined;
    totalCount?: number;
}

export interface NotificationDtoPagedResultDtoCommonResultDto {
    isSuccessful?: boolean;
    result?: NotificationDtoPagedResultDto;
    errorMessage?: string | undefined;
}

export interface PhieuBanGiaoDto {
    id?: number;
    ma?: string | undefined;
    nhanVienId?: number | undefined;
    nhanVienNhan?: number;
    createTime?: Date | undefined;
    tongThietBi?: number | undefined;
    danhSachThietBi?: number[] | undefined;
}

export interface PhieuBanGiaoDtoPagedResultDto {
    items?: PhieuBanGiaoDto[] | undefined;
    totalCount?: number;
}

export interface PhieuBaoDuongDto {
    id?: number;
    ma?: string | undefined;
    nhanVienId?: number | undefined;
    trangThai?: number | undefined;
    createTime?: Date | undefined;
    tongThietBi?: number | undefined;
    danhSachThietBi?: number[] | undefined;
}

export interface PhieuBaoDuongDtoCommonResultDto {
    isSuccessful?: boolean;
    result?: PhieuBaoDuongDto;
    errorMessage?: string | undefined;
}

export interface PhieuBaoDuongDtoPagedResultDto {
    items?: PhieuBaoDuongDto[] | undefined;
    totalCount?: number;
}

export interface PhieuBaoDuongInputDto {
    filter?: string | undefined;
    maxResultCount?: number | undefined;
    skipCount?: number | undefined;
    date?: Date | undefined;
}

export interface PhieuNhapXuatDto {
    id?: number;
    ma?: string | undefined;
    ngayNhapXuat?: Date;
    nhaCungCap?: string | undefined;
    nguoiDaiDien?: string | undefined;
    nhanVienId?: number;
    soLuong?: number | undefined;
    tongTien?: number | undefined;
    ghiChu?: string | undefined;
    loaiPhieu?: number;
    thongTinChiTietThietBiDtos?: ThongTinChiTietThietBiDto[] | undefined;
}

export interface PhieuNhapXuatDtoCommonResultDto {
    isSuccessful?: boolean;
    result?: PhieuNhapXuatDto;
    errorMessage?: string | undefined;
}

export interface PhieuNhapXuatDtoPagedResultDto {
    items?: PhieuNhapXuatDto[] | undefined;
    totalCount?: number;
}

export interface PhieuSuaChuaDto {
    id?: number;
    ma?: string | undefined;
    nhanVienId?: number;
    chiTietThietBiId?: number;
    trangThai?: number | undefined;
    lyDo?: string | undefined;
    createTime?: Date | undefined;
}

export interface PhieuSuaChuaDtoPagedResultDto {
    items?: PhieuSuaChuaDto[] | undefined;
    totalCount?: number;
}

export interface PhieuSuaChuaInputDto {
    filter?: string | undefined;
    maxResultCount?: number | undefined;
    skipCount?: number | undefined;
    date?: Date | undefined;
}

export interface PhieuThuHoiDto {
    id?: number;
    ma?: string | undefined;
    nhanVienId?: number | undefined;
    createTime?: Date | undefined;
    tongThietBi?: number | undefined;
    danhSachThietBiId?: number[] | undefined;
    danhSachThietBi?: ThongTinChiTietThietBiDto[] | undefined;
}

export interface PhieuThuHoiDtoPagedResultDto {
    items?: PhieuThuHoiDto[] | undefined;
    totalCount?: number;
}

export interface RegisterModel {
    username: string;
    email: string;
    password: string;
    nhanVienId?: number;
}

export interface RegisterModelCommonResultDto {
    isSuccessful?: boolean;
    result?: RegisterModel;
    errorMessage?: string | undefined;
}

export interface SearchListDto {
    filter?: string | undefined;
    maxResultCount?: number | undefined;
    skipCount?: number | undefined;
}

export interface ThietBiYTeDto {
    id?: number;
    ma?: string | undefined;
    ten?: string | undefined;
    mdrr?: string | undefined;
    loaiTTBYT?: string | undefined;
    soLuong?: number;
}

export interface ThietBiYTeDtoCommonResultDto {
    isSuccessful?: boolean;
    result?: ThietBiYTeDto;
    errorMessage?: string | undefined;
}

export interface ThietBiYTeDtoPagedResultDto {
    items?: ThietBiYTeDto[] | undefined;
    totalCount?: number;
}

export interface ThongKeDto {
    tongSoLuong?: number;
    tongSoTien?: number;
}

export interface ThongTinChiTietThietBiDto {
    id?: number;
    ma?: string | undefined;
    thietBiYTeId?: number;
    ngayNhap?: Date | undefined;
    xuatXu?: string | undefined;
    namSX?: number | undefined;
    hangSanXuat?: string | undefined;
    tinhTrang?: string | undefined;
    khoaId?: number | undefined;
    nhanVienId?: number | undefined;
    serial?: string | undefined;
    model?: string | undefined;
    giaTien?: number;
    thoiGianBaoDuong?: number;
    daXuat?: boolean | undefined;
}

export interface ThongTinChiTietThietBiDtoCommonResultDto {
    isSuccessful?: boolean;
    result?: ThongTinChiTietThietBiDto;
    errorMessage?: string | undefined;
}

export interface ThongTinChiTietThietBiDtoPagedResultDto {
    items?: ThongTinChiTietThietBiDto[] | undefined;
    totalCount?: number;
}

export interface ThongTinChiTietThietBiSelectDto {
    id?: number;
    ma?: string | undefined;
    nhanVienId?: number | undefined;
    daXuat?: boolean | undefined;
}

export interface ThongTinThietBiReaderDto {
    ma?: string | undefined;
    thietBiYTeId?: number;
    ngayNhap?: Date;
    xuatXu?: string | undefined;
    namSX?: number | undefined;
    hangSanXuat?: string | undefined;
    tinhTrang?: string | undefined;
    khoaId?: number | undefined;
    nhanVienId?: number | undefined;
    serial?: string | undefined;
    model?: string | undefined;
    giaTien?: number | undefined;
    thoiGianBaoDuong?: number | undefined;
}

export interface ThongTinThietBiReaderDtoReadFileExcelDto {
    validDtos?: ThongTinThietBiReaderDtoReadFileExcelItemDto[] | undefined;
    inValidDtos?: ThongTinThietBiReaderDtoReadFileExcelItemDto[] | undefined;
}

export interface ThongTinThietBiReaderDtoReadFileExcelItemDto {
    data?: ThongTinThietBiReaderDto;
    invalidErrors?: string[] | undefined;
    readonly isValid?: boolean;
}

export interface UserInfoDto {
    ma?: string | undefined;
    ten?: string | undefined;
    khoaId?: number | undefined;
    email?: string | undefined;
    sdt?: string | undefined;
    role?: string | undefined;
    nhanVienId?: number | undefined;
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}